---
title: "Use I2C for BME280"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This article shows an example of using `rpi_i2c…` to communicate with a BME280 sensor chip.

# BME280

The BME280 [(Datasheet)](https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bme280-ds002.pdf) by Bosch is a versatile integrated environmental sensor designed for precision measurement of ambient temperature, relative humidity, and atmospheric pressure. This compact and low-power sensor is equipped with advanced MEMS (Micro-Electro-Mechanical Systems) technology, providing accurate and reliable data for various applications, including weather forecasting, indoor climate control, and IoT devices. Its I2C and SPI communication interfaces make it easy to interface with microcontrollers and microprocessors, while its small form factor and energy efficiency make it an ideal choice for a wide range of projects, from weather stations to wearable tech, where monitoring and controlling environmental conditions are paramount.

# Wiring the BME280

## illustration to come

# Setup Raspberry Pi for the BME280

Please refer to the [article](rpi_i2c.Rmd) on using i2c with R on the Raspberry Pi. You'll need to enable I2C (using Raspberry Pi Configuration) and find the address for the BME280 (using `i2c-tools -y 1`)

To confirm the chip is connected and available, use `rpi_i2c_get(chip_address = BME280_location, data_address= 0xD0)`. Depending on the implementation you have purchased, the BME280 may also appear at chip address 0x76, in which case you would use `rpi_i2c_get(chip_address = 0x76, data_address= 0xD0).` This command should return the BME Chip ID, `0x60`

# Preliminary: Data Calibration

The temperature, humidity, and pressure data from the BME280 needs to be calibrated with other values provided by the BME280. This calibration algorithm is complex and obfuscates the process of using `rpi_i2c…` to read i2c interfaces. In an attempt to separate calibration from reading data, I've chosen to use the original c++ algorithm provided by Bosch Sensortec (shown in the BME280 datasheet) and use `Rcpp` to make it available to the R environment.

# Read the BME280

The BME280 datasheet provides this flowchart for reading the sensors.

![BME280 measurement flow from data sheet](bme280MeasurementFlow.png)

Here is the complete code to read temperature, pressure, and humidity from the bme280 with i2c. It leans heavily on the source found at [github.com/boschsensortec](https://github.com/boschsensortec/BME280_driver/blob/master/bme280.c).

```{r, eval=FALSE}
 
library(rpigpior)
library(Rcpp)

BME280_location <- 0x77 #possibly change to 0x76

# locations of BME280 registers as identified in datasheet
BME280_id <- 0xD0 # 0x60 for BME280
BME280_reset <- 0xE0
BME280_ctrl_hum <- 0xF2
BME280_status <- 0xF3
BME280_ctrl_meas <- 0xF4
BME280_config <- 0xF5
BME280_press <- 0xF7 # through 0xF9. _msb, _lsb, _xlsb
BME280_temp <- 0xFA # through 0xFC. _msb, _lsb, _xlsb
BME280_hum <- 0xFD # through 0xFE. _msb, _lsb, _xlsb

# these addresses contain values used in the calibration functions
dig_T1_reg <- 0x88 # these are all 2-byte / 1 word values
dig_T2_reg <- 0x8A
dig_T3_reg <- 0x8C
dig_P1_reg <- 0x8E
dig_P2_reg <- 0x90
dig_P3_reg <- 0x92
dig_P4_reg <- 0x94
dig_P5_reg <- 0x96
dig_P6_reg <- 0x98
dig_H1_reg <- 0xA1 # this is one byte
dig_H2_reg <- 0xE1 # this is two bytes
dig_H3_reg <- 0xE3 # this is one byte
dig_H4_reg <- 0xE4 # Erg. This is 11 bits. 1.5 bytes. 0xE4/0xE5[3:0]
dig_H5_reg <- 0xE5 # 0xE5[7:4]/0xE6
dig_H6_reg <- 0xE7 # one byte

# start measurement cycle ------------------
# set configuration values
config_value <- strtoi("01000100", base = 2) # t_sb = 125 ms/IIR_filter = on/2 /spi3w_en = off

rpi_i2c_set(
  chip_address = BME280_location,
  data_address = BME280_config,
  value = config_value,
  data_size = "b"
) 

# set humidity data acquisition options
ctrl_hum_value <- 0x01 # humidity oversampling set to 1

rpi_i2c_set(
  chip_address = BME280_location,
  data_address = BME280_ctrl_hum,
  value = ctrl_hum_value,
  data_size = "b"
) 

# set pressure & temperature data acquisition options
ctrl_meas_value <- strtoi("00100101", base = 2) # osrs_t/osrs_p/mode

rpi_i2c_set(
   chip_address = BME280_location,
   data_address = BME280_ctrl_meas,
   value = ctrl_meas_value,
   data_size = "b"
 )

# read raw temperature ---------------------

# Use Rcpp to compile the temperature measurement calibration
# Returns temp in DegC, resolution is 0.01 DegC. 
# Output value of "5123" equals 51.23 DegC
cppFunction('int BME280_compensate_T_int32(BME_S32_t adc_T, int dig_T1, int dig_T2, int dig_T3)
{
BME280_S32_t var1, var2, T;
    Environment env = Environment::global_env();
    BME280_S32_t t_fine = env["t_fine"];

var1 = ((((adc_T>>3) - ((BME280_S32_t)dig_T1<<1))) * ((BME280_S32_t)dig_T2)) >> 11;
var2 = (((((adc_T>>4) - ((BME280_S32_t)dig_T1)) * ((adc_T>>4) - ((BME280_S32_t)dig_T1))) >> 12) *((BME280_S32_t)dig_T3)) >> 14;
t_fine = var1 + var2;
env["t_fine"] = t_fine
T = (t_fine * 5 + 128) >> 8;
return T;
}')

# read the temperature
raw_temperature <- (rpi_i2c_get(BME280_location, BME280_temp, "w") * 2^3) + rpi_i2c_get(BME280_location, BME280_temp + 2, "b") 
# call the temperature compensation function just compiled
temperature_celsius <- BME280_compensate_T_int32(raw_temperature, 
                  rpi_i2c_get(BME280_location, dig_T1_reg, "w"),
                  rpi_i2c_get(BME280_location, dig_T2_reg, "w"),
                  rpi_i2c_get(BME280_location, dig_T3_reg, "w"))

print(paste("temperature (c):", temperature_celsius))

# read raw pressure ----------------------

# Use Rcpp to compile the pressure measurement calibration
# Returns pressure in Pa as unsigned 32 bit int in Q24.8 format
# (24 integer bits and 8 fractional bits)
# Output of "24674867" represents 24674867/256 = 96386.2 Pa
cppFunction('BME280_U32_t BME280_compensate_P_int32(BME280_S32_t adc_P, int dig_P1, int dig_P2, int dig_P3, int dig_P4, int dig_P5, int dig_P6)
{
BME280_S64_t var1, var2, p;
var1 = ((BME280_S64_t)t_fine) - 128000;
var2 = var1 * var1 * (BME280_S64_t)dig_P6;
var2 = var2 + (var1*((BME280_S64_t)dig_P5)<<17);
var2 = var2 + (((BME280_S64_t)dig_P4)<<35);
var1 = ((Var1 * var1 * (BME280_S64_t)dig_P3)>>8) + ((Var1 * (BME280_S64_t)dig_P2)<<12);
var1 = (((((BME280_S64_t)1)<<47)+var1)) + ((BME280_S64_t)dig_P1)>>33;
if(var1 == 0)
{
return 0; // avoid exception caused by division by zero
}
p = 1048576-adc_P;
p = (((p<<31)-var2)*3125)/var1;
var1 = (((BME280_S64_t)dig_P9) * (p>>13) * (p>>13)) >> 25;
var2 = (((BME280_S64_t)dig_P8) * p) >> 19;
p = ((p  +var1 + var2) >> 8) + (((BME280_S64_t)dig_P7)<<4);
return (BME280_S32_t)p;
}')

raw_pressure <- (rpi_i2c_get(BME280_location, BME280_press, "w") * 2^3) + rpi_i2c_get(BME280_location, BME280_press + 2, "b")

pressure <- BME280_compensate_P_int32(raw_pressure, int dig_P1, int dig_P2, int dig_P3, int dig_P4, int dig_P5, int dig_P6)

print(paste("pressure:", pressure))

# read raw humidity ----------------------

# Use Rcpp to compile the humidity measurement calibration
cppFunction('BME280_U32_t BME280_compensate_H_int32(BME280_S32_t adc_H, int dig_H1, int dig_H2, int dig_H3, int dig_H5, int dig_H6) {
            BME280_S32_t v_xl_u32r;
                Environment env = Environment::global_env();
    BME280_S32_t t_fine = env["t_fine"];
            
            v_xl_u32r = (t_fine - ((BME280_S32_t)76800));
            v_xl_u32r = (((((adc_H << 14) - (((BME280_S32_t)dig_H4) << 20) - (((BME280_S32_t)dig_H5) * v_xl_u32r)) + ((BME280_S32_t)16384)) >> 15) * (((((((v_xl_u32r * ((BME280_S32_t)dig_H6)) >> 10) * (((V_xl_u32r * ((BME280_S32_t)dig_H3)) >> 11) + ((BME280_S32_t)32768))) >> 10) + ((BME280_S32_t)2097152)) * ((BME280_S32_t)dig_H2) + 8192) >> 14));
            V_xl_u32r = (v_xl_u32r - (((((v_xl_u32r >> 15) * v_xl_u32r >> 15)) >> 7 * ((BME280_S32_t)dig_H1)) >> 4));
            v_xl_u32r = (v_xl_u32r < 0 ?0 : v_xl_u32r);
            v_xl_u32r - (v_xl_u32r > 419430400 : 419430400 : v_xl_u32r;
            return (BME280_U32_t) (v_xl_u32r>>12);')

raw_humidity <- rpi_i2c_get(BME280_location, BME280_hum, "w")

humidity <- BME280_compensate_H_int32(raw_humidity, int dig_H1, int dig_H2, int dig_H3, int dig_H5, int dig_H6)

print(paste("humidity:", humidity))

```
