[{"path":"https://mnr.github.io/rpigpior/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 rpigpior authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"understanding-gpio","dir":"Articles","previous_headings":"","what":"Understanding GPIO","title":"How to write GPIO Code with rpigpiodr and R","text":"GPIO stands General Purpose Input/Output. can “see” Raspberry Pi; ’s dual row pins along one edge. two rows twenty pins total forty pins. GPIO pins can deliver 3.3 volts direct current (DC), 5 volts DC, ground, multipurpose input output pins. pins also deliver specialty functions I2C, SPI, UART, 1-wire, PWM. don’t pay attention pin functions connect things GPIO, zap Raspberry Pi. ’s bad thing.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"gpio-implies-connecting-wires","dir":"Articles","previous_headings":"","what":"GPIO implies connecting wires","title":"How to write GPIO Code with rpigpiodr and R","text":"stray world Raspberry Pi, ’s intent connect sensors devices GPIO pins. implies circuits wires. can show , assume already gone excellent tutorials Raspberry Pi foundation places LinkedIn Learning.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"reading-a-switch","dir":"Articles","previous_headings":"","what":"Reading a switch","title":"How to write GPIO Code with rpigpiodr and R","text":"Let’s talk illustration. Connecting switch Raspberry Pi","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"pins-and-identifiers","dir":"Articles","previous_headings":"Reading a switch","what":"Pins and Identifiers","title":"How to write GPIO Code with rpigpiodr and R","text":"bottom picture Raspberry Pi. Along top two rows pins expose GPIO. several ways identify pins: Physical/Board - identification scheme used rpigpior. number pin board. Pin 1 inner (lower) left side. Pin 2 outer (upper) left side. Pin 40 outer right side. diagram, ’ll see yellow wire connected. BCM - signal found Broadcom chip (BCM2835 others) used power GPIO. example, Board pin 5 (third pin left lower (inside) row) connected BCM signal line 3. ’ll often see referred GPIO03. Yes, confusing, make sense understand designers . Wiring Pi - system written admirers Arduino. Wiring Pi popular among C programming crowd. don’t use rpigpior.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"schematics","dir":"Articles","previous_headings":"Reading a switch","what":"Schematics","title":"How to write GPIO Code with rpigpiodr and R","text":"top illustration white box grid dots. called breadboard exactly look like. top bottom two horizontal rows (four rows total). holes horizontal row electrically connected together. called rails. attach five volts top right corner hole, read five volts top left corner. middle two grids separated gutter. grid five rows thirty columns. holes column connected - across grid. attached five volts first column, first row, read five volts first column, fifth row. Breadboards used wires, resistors, capacitors, switches, lights, microcircuits (transistors) quickly prototype electrical circuits. case, switch connected Raspberry Pi yellow red wire.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"connect-a-switch-to-the-raspberry-pi","dir":"Articles","previous_headings":"Reading a switch","what":"Connect a switch to the Raspberry Pi","title":"How to write GPIO Code with rpigpiodr and R","text":"illustration shows connect pushbutton Raspberry Pi. case, red wire connects board pin 17 one side pushbutton. Board pin 17 supplies 3.3 volts DC. yellow wire connects board pin 40 side pushbutton. Board pin 40 connects Broadcom microcircuit exposes GPIO21. allows Raspberry Pi read state pushbutton.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"programming","dir":"Articles","previous_headings":"","what":"Programming","title":"How to write GPIO Code with rpigpiodr and R","text":"Consider code: pass () loop, program read state board pin 40 rpi_get(40). button pushed, print(\"Button Pushed\"). pin 40 pushed, print(\"Button pushed\")","code":"library(rpigpior)  while (TRUE) {   if (rpi_get(40)) {     print(\"Button pushed\")   } else {     print(\"Button not pushed\")   } }"},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"setting-a-pin","dir":"Articles","previous_headings":"","what":"Setting a pin","title":"How to write GPIO Code with rpigpiodr and R","text":"Now consider new illustration, adds previous circuit.  sorts new things happening. red wire connects board pin 17 lowest rail. supplies 3.3 volts. black wire connects board pin 14 next lowest rail. supplies ground. wiring switch electrically previous illustration: yellow wire connects one side switch board pin 40 () red wire connects 3.3 volt rail side switch. LED (Light Emitting Diode) added breadboard. black wire connects top rail (ground) cathode LED. 220 ohm resistor connected anode LED. connected via green wire board pin 3.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"code-to-blink-an-led","dir":"Articles","previous_headings":"","what":"Code to blink an LED","title":"How to write GPIO Code with rpigpiodr and R","text":"Given circuit, code blink LED Notice addition rpi_set(3,1). tells Raspberry Pi turn board pin 3 . rpi_set(3,0) tells Raspberry Pi turn board pin 3 . loop reads state switch rpi_get(40). button pushed, LED attached pin 3 blink; 1 second , 3 seconds .","code":"library(rpigpior)  while (TRUE) {   if (rpi_get(40)) {          rpi_set(3,1)     Sys.sleep(1)          rpi_set(3,0)     Sys.sleep(3)   } }"},{"path":"https://mnr.github.io/rpigpior/articles/gpioCode.html","id":"hello-world","dir":"Articles","previous_headings":"","what":"hello world","title":"How to write GPIO Code with rpigpiodr and R","text":", Raspberry Pi equivalent hello world program. ’ve just learned: wire simple Raspberry Pi circuit switch LED. use R programming language control LED based Raspberry Pi","code":""},{"path":"https://mnr.github.io/rpigpior/articles/how-to-RPi.html","id":"how-to-set-up-r-for-a-raspberry-pi","dir":"Articles","previous_headings":"","what":"How to set up R for a Raspberry Pi","title":"How to Setup R on Raspberry Pi","text":"document describes set R programming language Raspberry Pi.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/how-to-RPi.html","id":"a-brief-overview-of-the-raspberry-pi","dir":"Articles","previous_headings":"How to set up R for a Raspberry Pi","what":"A brief overview of the Raspberry Pi","title":"How to Setup R on Raspberry Pi","text":"Raspberry Pi Model 4 Hopefully really isn’t necessary, may wonder ’s fuss Raspberry Pi. ’s tidbits get started: ’s full-blown Linux computer, supports HDMI, ethernet, audio, camera, USB runs five volts DC. consumes somewhere around 3 6 watts. See dual rows pins? ’s General Purpose Input/Output (GPIO) pins. can read write outside world, plus support wide array sensors. lots support programming Python Depending model need, get hands Raspberry Pi somewhere $5 $45 USD.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/how-to-RPi.html","id":"install-r","dir":"Articles","previous_headings":"How to set up R for a Raspberry Pi","what":"Install R","title":"How to Setup R on Raspberry Pi","text":"Raspberry Pi doesn’t come R ’ll need install . might want check R4Pi, website provides precompiled binaries. R4Pi website isn’t running, simply fall back apt-get… Unfortunately, installs R Root, cause problems install.packages( ) since don’t access library folder. fixed Raspberry Pi, didn’t take notes . figure , ’ll update document. apologies.","code":"sudo apt-get update sudo apt-get install r-base r-base-core"},{"path":"https://mnr.github.io/rpigpior/articles/how-to-RPi.html","id":"fix-the-app-menu","dir":"Articles","previous_headings":"How to set up R for a Raspberry Pi","what":"Fix the App Menu","title":"How to Setup R on Raspberry Pi","text":"Unfortunately, installer places R graphic menu instead programming tools. R appears graphic menu works, ’s just annoying. move programming menu: Go RPi menu (Raspberry Pi upper left). Select Preferences Select Main Menu Editor. provides dialog. dialog, select programming. right, select New Item: dialog, fill fields : Name=R Command=R Launch terminal. OK Presto change-O. R now programming menu.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/how-to-RPi.html","id":"fix-the-icon","dir":"Articles","previous_headings":"How to set up R for a Raspberry Pi","what":"Fix the Icon","title":"How to Setup R on Raspberry Pi","text":"Almost done trivial stuff, Icon R app wrong. Let’s fix …  Raspberry Pi menu, right click R. Choose Properties Click Icon bring chooser System Theme, select rlogo.icon","code":""},{"path":"https://mnr.github.io/rpigpior/articles/how-to-RPi.html","id":"setup-geany","dir":"Articles","previous_headings":"How to set up R for a Raspberry Pi","what":"Setup Geany","title":"How to Setup R on Raspberry Pi","text":"Apparently posit working version RStudio Raspberry Pi. creation document, ’s ready prime time. use Geany instead - ’s installed Raspberry Pi, ’s IDE, ’s better poke eye. Configuring geany R things set using Geany R. learned Geany documentation: https://wiki.geany.org/howtos/using_geany_with_r https://wiki.geany.org/howtos/configurebuildmenu Start edit -> preferences -> terminal check execute programs VTE. runs R Geany terminal rather opening separate terminal window. isn’t necessary, just nice--. Next Build -> Set Build Commands opens dialog. Enter Rscript ./%f Execute : Command. setup, run R program selecting Build -> Execute. Graphs output saved next input file. dialog, go first row. Click cell Label enter something descriptive like “R CMD.” next cell (COMMAND) enter R CMD BATCH ./f . command now appears top Build menu. Selecting option run command, capturing STDOUT xxx.Rout file. Note file names spaces.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/how-to-RPi.html","id":"install-libgpiod","dir":"Articles","previous_headings":"How to set up R for a Raspberry Pi","what":"Install libgpiod","title":"How to Setup R on Raspberry Pi","text":"Current versions Raspbian libgpiod installed default. get errors, use install necessary files:","code":"sudo apt-get update sudo apt-get install libgpiod-dev gpiod"},{"path":"https://mnr.github.io/rpigpior/articles/i2cbme280.html","id":"bme280","dir":"Articles","previous_headings":"","what":"BME280","title":"Use I2C for BME280","text":"BME280 (Datasheet) Bosch versatile integrated environmental sensor designed precision measurement ambient temperature, relative humidity, atmospheric pressure. compact low-power sensor equipped advanced MEMS (Micro-Electro-Mechanical Systems) technology, providing accurate reliable data various applications, including weather forecasting, indoor climate control, IoT devices. I2C SPI communication interfaces make easy interface microcontrollers microprocessors, small form factor energy efficiency make ideal choice wide range projects, weather stations wearable tech, monitoring controlling environmental conditions paramount.","code":""},{"path":[]},{"path":[]},{"path":"https://mnr.github.io/rpigpior/articles/i2cbme280.html","id":"setup-raspberry-pi-for-the-bme280","dir":"Articles","previous_headings":"","what":"Setup Raspberry Pi for the BME280","title":"Use I2C for BME280","text":"Please refer article using i2c R Raspberry Pi. ’ll need enable I2C (using Raspberry Pi Configuration) find address BME280 (using i2c-tools -y 1) confirm chip connected available, use rpi_i2c_get(chip_address = BME280_location, data_address= 0xD0). Depending implementation purchased, BME280 may also appear chip address 0x76, case use rpi_i2c_get(chip_address = 0x76, data_address= 0xD0). command return BME Chip ID, 0x60","code":""},{"path":"https://mnr.github.io/rpigpior/articles/i2cbme280.html","id":"preliminary-data-calibration","dir":"Articles","previous_headings":"","what":"Preliminary: Data Calibration","title":"Use I2C for BME280","text":"temperature, humidity, pressure data BME280 needs calibrated values provided BME280. calibration algorithm complex obfuscates process using rpi_i2c… read i2c interfaces. attempt separate calibration reading data, ’ve chosen use original c++ algorithm provided Bosch Sensortec (shown BME280 datasheet) use Rcpp make available R environment. Calibration requires values obtained BME280. values can identified dig_T1…, dig_H1…, dig_P1…followed _reg (register location hex) _value (value register). placed retrieval values close related function calls, values stored BME280 non-volatile RAM. never change, looping data acquisition, performance improve move i2c calls calibration values outside loop.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/i2cbme280.html","id":"read-the-bme280","dir":"Articles","previous_headings":"","what":"Read the BME280","title":"Use I2C for BME280","text":"BME280 datasheet provides flowchart reading sensors. BME280 measurement flow data sheet complete code read temperature, pressure, humidity bme280 i2c. leans heavily source found github.com/boschsensortec.","code":"library(rpigpior) library(Rcpp)  BME280_location <- 0x77 #possibly change to 0x76  # locations of BME280 registers as identified in datasheet BME280_id <- 0xD0 # 0x60 for BME280 BME280_reset <- 0xE0 BME280_ctrl_hum <- 0xF2 BME280_status <- 0xF3 BME280_ctrl_meas <- 0xF4 BME280_config <- 0xF5 BME280_press <- 0xF7 # through 0xF9. _msb, _lsb, _xlsb BME280_temp <- 0xFA # through 0xFC. _msb, _lsb, _xlsb BME280_hum <- 0xFD # through 0xFE. _msb, _lsb, _xlsb  # these addresses contain values used in the calibration functions dig_T1_reg <- 0x88 # these are all 2-byte / 1 word values dig_T2_reg <- 0x8A dig_T3_reg <- 0x8C dig_P1_reg <- 0x8E dig_P2_reg <- 0x90 dig_P3_reg <- 0x92 dig_P4_reg <- 0x94 dig_P5_reg <- 0x96 dig_P6_reg <- 0x98 dig_P7_reg <- 0x9A dig_P8_reg <- 0x9C dig_P9_reg <- 0x9E dig_H1_reg <- 0xA1 # this is one byte dig_H2_reg <- 0xE1 # this is two bytes dig_H3_reg <- 0xE3 # this is one byte dig_H4_reg <- 0xE4 # Erg. This is 11 bits. 1.5 bytes. 0xE4/0xE5[3:0] dig_H5_reg <- 0xE5 # 0xE5[7:4]/0xE6 dig_H6_reg <- 0xE7 # one byte  # start measurement cycle ------------------ # set configuration values config_value <- strtoi(\"01000100\", base = 2) # t_sb = 125 ms/IIR_filter = on/2 /spi3w_en = off  rpi_i2c_set(   chip_address = BME280_location,   data_address = BME280_config,   value = config_value,   data_size = \"b\" )   # set humidity data acquisition options ctrl_hum_value <- 0x01 # humidity oversampling set to 1  rpi_i2c_set(   chip_address = BME280_location,   data_address = BME280_ctrl_hum,   value = ctrl_hum_value,   data_size = \"b\" )   # set pressure & temperature data acquisition options ctrl_meas_value <- strtoi(\"00100101\", base = 2) # osrs_t/osrs_p/mode  rpi_i2c_set(    chip_address = BME280_location,    data_address = BME280_ctrl_meas,    value = ctrl_meas_value,    data_size = \"b\"  )  # read raw temperature ---------------------  # Use Rcpp to compile the temperature measurement calibration # Returns temp in DegC, resolution is 0.01 DegC.  # Output value of \"5123\" equals 51.23 DegC # cppFunction('Rcpp::IntegerVector BME280_compensate_T_int32(Rcpp::IntegerVector adc_T, Rcpp::IntegerVector dig_T1, Rcpp::IntegerVector dig_T2, Rcpp::IntegerVector dig_T3) # { #long signed int var1, var2, T; #    Environment env = Environment::global_env(); #    long signed int t_fine;  #var1 = ((((adc_T>>3) - (dig_T1<<1))) * (dig_T2)) >> 11; #var2 = (((((adc_T>>4) - (dig_T1)) * ((adc_T>>4) - dig_T1)) >> 12) *dig_T3) >> 14; #t_fine = var1 + var2; #env[\"t_fine\"] = t_fine; #T = (t_fine * 5 + 128) >> 8; #return T; #}')  # read the temperature MsbLsb <- bitwShiftL(rpi_i2c_get(BME280_location, BME280_temp, \"w\"),4) xlsb <- rpi_i2c_get(BME280_location, BME280_temp + 2, \"b\") raw_temperature <- bitwOr(MsbLsb, xlsb) # call the temperature compensation function just compiled dig_T1_value <- rpi_i2c_get(BME280_location, dig_T1_reg, \"w\") dig_T2_value <- rpi_i2c_get(BME280_location, dig_T2_reg, \"w\") dig_T3_value <- rpi_i2c_get(BME280_location, dig_T3_reg, \"w\")  # perform the calculation --------------------------  t_var1 <- bitShiftR((bitShiftR(raw_temperature, 3) - bitShiftL(dig_T1_value, 1)) * dig_T2_value, 11)  t_var2 <- bitShiftR(bitShiftR((bitShiftR(adc_T, 4) - dig_T1_value) * (bitShiftR(adc_T, 4) - dig_T1_value), 12) * dig_T3_value, 14)  t_fine <- t_var1 + t_var2; temperature_celsius <- bitwShiftR((t_fine * 5 + 128),8)  # temperature_celsius <- BME280_compensate_T_int32(raw_temperature, dig_T1_value,dig_T2_value,dig_T3_value)  print(paste(\"temperature (c):\", (temperature_celsius/100)))  # read raw pressure ----------------------  # Use Rcpp to compile the pressure measurement calibration # Returns pressure in Pa as unsigned 32 bit int in Q24.8 format # (24 integer bits and 8 fractional bits) # Output of \"24674867\" represents 24674867/256 = 96386.2 Pa cppFunction('long unsigned int BME280_compensate_P_int32(long signed int adc_P, int dig_P1, int dig_P2, int dig_P3, int dig_P4, int dig_P5, int dig_P6, int dig_P7, int dig_P8, int dig_P9) { long long unsigned int var1, var2, p;    Environment env = Environment::global_env();     long signed int t_fine = env[\"t_fine\"];  var1 = ((long long unsigned int)t_fine) - 128000; var2 = var1 * var1 * (long long unsigned int)dig_P6; var2 = var2 + (var1*((long long unsigned int)dig_P5)<<17); var2 = var2 + (((long long unsigned int)dig_P4)<<35); var1 = ((var1 * var1 * (long long unsigned int)dig_P3)>>8) + ((var1 * (long long unsigned int)dig_P2)<<12); var1 = (((((long long unsigned int)1)<<47)+var1)) + ((long long unsigned int)dig_P1)>>33; if(var1 == 0) { return 0; // avoid exception caused by division by zero } p = 1048576-adc_P; p = (((p<<31)-var2)*3125)/var1; var1 = (((long long unsigned int)dig_P9) * (p>>13) * (p>>13)) >> 25; var2 = (((long long unsigned int)dig_P8) * p) >> 19; p = ((p  +var1 + var2) >> 8) + (((long long unsigned int)dig_P7)<<4); return (long signed int)p; }')  raw_pressure <- bitwShiftL(rpi_i2c_get(BME280_location, BME280_press, \"w\"),4) + bitwShiftR(rpi_i2c_get(BME280_location, BME280_press + 2, \"b\"),4)  pressure <- BME280_compensate_P_int32(raw_pressure,                  rpi_i2c_get(BME280_location, dig_P1_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P2_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P3_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P4_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P5_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P6_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P7_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P8_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_P9_reg, \"w\") )  print(paste(\"pressure (Pa):\", (pressure/256)))  # read raw humidity ----------------------  # Use Rcpp to compile the humidity measurement calibration # returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits) # output value of \"47445\" represents 4755/1024 = 46.333 %RH cppFunction('long unsigned int BME280_compensate_H_int32(long signed int adc_H, int dig_H1, int dig_H2, int dig_H3, int dig_H4, int dig_H5, int dig_H6) {             long signed int v_xl_u32r;                 Environment env = Environment::global_env();     long signed int t_fine = env[\"t_fine\"];                          v_xl_u32r = (t_fine - ((long signed int)76800));             v_xl_u32r = (((((adc_H << 14)                        - (((long signed int)dig_H4) << 20)                        - (((long signed int)dig_H5)                        * v_xl_u32r))                        + ((long signed int)16384)) >> 15)                        * (((((((v_xl_u32r                        * ((long signed int)dig_H6)) >> 10)                        * (((v_xl_u32r                        * ((long signed int)dig_H3)) >> 11)                        + ((long signed int)32768))) >> 10)                        + ((long signed int)2097152))                        * ((long signed int)dig_H2) + 8192) >> 14));             v_xl_u32r = (v_xl_u32r - (((((v_xl_u32r >> 15)                       * v_xl_u32r >> 15)) >> 7                       * ((long signed int)dig_H1)) >> 4));             v_xl_u32r = (v_xl_u32r < 0 ?0 : v_xl_u32r);             v_xl_u32r = (v_xl_u32r > 419430400 ? 419430400 : v_xl_u32r);             return (long unsigned int) (v_xl_u32r>>12);}')  raw_humidity <- rpi_i2c_get(BME280_location, BME280_hum, \"w\")  # 11 bits. 1.5 bytes. 0xE4/0xE5[3:0] dig_H4_value <- bitwShiftL(rpi_i2c_get(BME280_location, dig_H4_reg, \"b\"),4) + bitwAnd(rpi_i2c_get(BME280_location, dig_H4_reg + 1, \"b\"), 0x0F)  dig_H5_value <- bitwShiftL(bitwAnd(rpi_i2c_get(BME280_location, dig_H5_reg, \"b\"),0xF0),4) + rpi_i2c_get(BME280_location, dig_H5_reg + 1, \"b\")  humidity <- BME280_compensate_H_int32(raw_humidity,                  rpi_i2c_get(BME280_location, dig_H1_reg, \"b\"),                 rpi_i2c_get(BME280_location, dig_H2_reg, \"w\"),                 rpi_i2c_get(BME280_location, dig_H3_reg, \"b\"),                 dig_H4_value,                 dig_H5_value,                 rpi_i2c_get(BME280_location, dig_H6_reg, \"b\"))  print(paste(\"humidity (%RH):\", (humidity/1024)))"},{"path":"https://mnr.github.io/rpigpior/articles/i2cbme280.html","id":"optimized","dir":"Articles","previous_headings":"","what":"Optimized","title":"Use I2C for BME280","text":"code, optimized repeat every one second","code":"library(rpigpior) library(Rcpp)  BME280_location <- 0x77 #possibly change to 0x76  # locations of BME280 registers as identified in datasheet BME280_id <- 0xD0 # 0x60 for BME280 BME280_reset <- 0xE0 BME280_ctrl_hum <- 0xF2 BME280_status <- 0xF3 BME280_ctrl_meas <- 0xF4 BME280_config <- 0xF5 BME280_press <- 0xF7 # through 0xF9. _msb, _lsb, _xlsb BME280_temp <- 0xFA # through 0xFC. _msb, _lsb, _xlsb BME280_hum <- 0xFD # through 0xFE. _msb, _lsb, _xlsb  # these addresses contain values used in the calibration functions dig_T1_reg <- 0x88 # these are all 2-byte / 1 word values dig_T1_value <- rpi_i2c_get(BME280_location, dig_T1_reg, \"w\")  dig_T2_reg <- 0x8A dig_T2_value <- rpi_i2c_get(BME280_location, dig_T2_reg, \"w\")  dig_T3_reg <- 0x8C dig_T3_value <- rpi_i2c_get(BME280_location, dig_T3_reg, \"w\")  dig_P1_reg <- 0x8E dig_P1_value <- rpi_i2c_get(BME280_location, dig_P1_reg, \"w\")  dig_P2_reg <- 0x90 dig_P2_value <- rpi_i2c_get(BME280_location, dig_P2_reg, \"w\")  dig_P3_reg <- 0x92 dig_P3_value <- rpi_i2c_get(BME280_location, dig_P3_reg, \"w\")  dig_P4_reg <- 0x94 dig_P4_value <- rpi_i2c_get(BME280_location, dig_P4_reg, \"w\")  dig_P5_reg <- 0x96 dig_P5_value <- rpi_i2c_get(BME280_location, dig_P5_reg, \"w\")  dig_P6_reg <- 0x98 dig_P6_value <- rpi_i2c_get(BME280_location, dig_P6_reg, \"w\")  dig_P7_reg <- 0x9A dig_P7_value <- rpi_i2c_get(BME280_location, dig_P7_reg, \"w\")  dig_P8_reg <- 0x9C dig_P8_value <- rpi_i2c_get(BME280_location, dig_P8_reg, \"w\")  dig_P9_reg <- 0x9E dig_P9_value <- rpi_i2c_get(BME280_location, dig_P9_reg, \"w\")  dig_H1_reg <- 0xA1 # this is one byte dig_H1_value <- rpi_i2c_get(BME280_location, dig_H1_reg, \"b\")  dig_H2_reg <- 0xE1 # this is two bytes dig_H2_value <- rpi_i2c_get(BME280_location, dig_H2_reg, \"w\")  dig_H3_reg <- 0xE3 # this is one byte dig_H3_value <- rpi_i2c_get(BME280_location, dig_H3_reg, \"b\")  dig_H4_reg <- 0xE4 # Erg. This is 11 bits. 1.5 bytes. 0xE4/0xE5[3:0] dig_H4_value <- bitwShiftL(rpi_i2c_get(BME280_location, dig_H4_reg, \"b\"),4) + bitwAnd(rpi_i2c_get(BME280_location, dig_H4_reg + 1, \"b\"), 0x0F)  dig_H5_reg <- 0xE5 # 0xE5[7:4]/0xE6 dig_H5_value <- bitwShiftL(bitwAnd(rpi_i2c_get(BME280_location, dig_H5_reg, \"b\"),0xF0),4) + rpi_i2c_get(BME280_location, dig_H5_reg + 1, \"b\")  dig_H6_reg <- 0xE7 # one byte dig_H6_value <- rpi_i2c_get(BME280_location, dig_H6_reg, \"b\")  # set configuration values config_value <- strtoi(\"01000100\", base = 2) # t_sb = 125 ms/IIR_filter = on/2 /spi3w_en = off  rpi_i2c_set(   chip_address = BME280_location,   data_address = BME280_config,   value = config_value,   data_size = \"b\" )   # set humidity data acquisition options ctrl_hum_value <- 0x01 # humidity oversampling set to 1  rpi_i2c_set(   chip_address = BME280_location,   data_address = BME280_ctrl_hum,   value = ctrl_hum_value,   data_size = \"b\" )   # set pressure & temperature data acquisition options ctrl_meas_value <- strtoi(\"00100101\", base = 2) # osrs_t/osrs_p/mode  # Use Rcpp to compile the temperature measurement calibration # Returns temp in DegC, resolution is 0.01 DegC.  # Output value of \"5123\" equals 51.23 DegC cppFunction('int BME280_compensate_T_int32(long signed int adc_T, int dig_T1, int dig_T2, int dig_T3) { long signed int var1, var2, T;     Environment env = Environment::global_env();     long signed int t_fine;  var1 = ((((adc_T>>3) - ((long signed int)dig_T1<<1))) * ((long signed int)dig_T2)) >> 11; var2 = (((((adc_T>>4) - ((long signed int)dig_T1)) * ((adc_T>>4) - ((long signed int)dig_T1))) >> 12) *((long signed int)dig_T3)) >> 14; t_fine = var1 + var2; env[\"t_fine\"] = t_fine; T = (t_fine * 5 + 128) >> 8; return T; }')  # Use Rcpp to compile the pressure measurement calibration # Returns pressure in Pa as unsigned 32 bit int in Q24.8 format # (24 integer bits and 8 fractional bits) # Output of \"24674867\" represents 24674867/256 = 96386.2 Pa cppFunction('long unsigned int BME280_compensate_P_int32(long signed int adc_P, int dig_P1, int dig_P2, int dig_P3, int dig_P4, int dig_P5, int dig_P6, int dig_P7, int dig_P8, int dig_P9) { long long unsigned int var1, var2, p;    Environment env = Environment::global_env();     long signed int t_fine = env[\"t_fine\"];  var1 = ((long long unsigned int)t_fine) - 128000; var2 = var1 * var1 * (long long unsigned int)dig_P6; var2 = var2 + (var1*((long long unsigned int)dig_P5)<<17); var2 = var2 + (((long long unsigned int)dig_P4)<<35); var1 = ((var1 * var1 * (long long unsigned int)dig_P3)>>8) + ((var1 * (long long unsigned int)dig_P2)<<12); var1 = (((((long long unsigned int)1)<<47)+var1)) + ((long long unsigned int)dig_P1)>>33; if(var1 == 0) { return 0; // avoid exception caused by division by zero } p = 1048576-adc_P; p = (((p<<31)-var2)*3125)/var1; var1 = (((long long unsigned int)dig_P9) * (p>>13) * (p>>13)) >> 25; var2 = (((long long unsigned int)dig_P8) * p) >> 19; p = ((p  +var1 + var2) >> 8) + (((long long unsigned int)dig_P7)<<4); return (long signed int)p; }')  # Use Rcpp to compile the humidity measurement calibration # returns humidity in %RH as unsigned 32 bit integer in Q22.10 format (22 integer and 10 fractional bits) # output value of \"47445\" represents 4755/1024 = 46.333 %RH cppFunction('long unsigned int BME280_compensate_H_int32(long signed int adc_H, int dig_H1, int dig_H2, int dig_H3, int dig_H4, int dig_H5, int dig_H6) {             long signed int v_xl_u32r;                 Environment env = Environment::global_env();     long signed int t_fine = env[\"t_fine\"];                          v_xl_u32r = (t_fine - ((long signed int)76800));             v_xl_u32r = (((((adc_H << 14)                        - (((long signed int)dig_H4) << 20)                        - (((long signed int)dig_H5)                        * v_xl_u32r))                        + ((long signed int)16384)) >> 15)                        * (((((((v_xl_u32r                        * ((long signed int)dig_H6)) >> 10)                        * (((v_xl_u32r                        * ((long signed int)dig_H3)) >> 11)                        + ((long signed int)32768))) >> 10)                        + ((long signed int)2097152))                        * ((long signed int)dig_H2) + 8192) >> 14));             v_xl_u32r = (v_xl_u32r - (((((v_xl_u32r >> 15)                       * v_xl_u32r >> 15)) >> 7                       * ((long signed int)dig_H1)) >> 4));             v_xl_u32r = (v_xl_u32r < 0 ?0 : v_xl_u32r);             v_xl_u32r = (v_xl_u32r > 419430400 ? 419430400 : v_xl_u32r);             return (long unsigned int) (v_xl_u32r>>12);}')   # start measurement cycle ------------------  while (TRUE) { rpi_i2c_set(   chip_address = BME280_location,   data_address = BME280_ctrl_meas,   value = ctrl_meas_value,   data_size = \"b\" )  # read raw temperature ---------------------  raw_temperature <- bitwShiftL(rpi_i2c_get(BME280_location, BME280_temp, \"w\"),4) + bitwShiftR(rpi_i2c_get(BME280_location, BME280_temp + 2, \"b\"),4) # call the temperature compensation function just compiled temperature_celsius <- BME280_compensate_T_int32(raw_temperature, dig_T1_value,dig_T2_value,dig_T3_value)   # read raw pressure ---------------------- raw_pressure <- bitwShiftL(rpi_i2c_get(BME280_location, BME280_press, \"w\"),4) + bitwShiftR(rpi_i2c_get(BME280_location, BME280_press + 2, \"b\"),4)  pressure <- BME280_compensate_P_int32(raw_pressure,                     dig_P1_value, dig_P2_value, dig_P3_value,                     dig_P4_value, dig_P5_value, dig_P6_value,                     dig_P7_value, dig_P8_value, dig_P9_value)   # read raw humidity ----------------------  raw_humidity <- rpi_i2c_get(BME280_location, BME280_hum, \"w\")  humidity <- BME280_compensate_H_int32(raw_humidity,                                        dig_H1_value,                                       dig_H2_value,                                       dig_H3_value,                                       dig_H4_value,                                       dig_H5_value,                                       dig_H6_value)  print(paste(\"temperature (c):\", (temperature_celsius/100), \"pressure (Pa):\", (pressure/256), \"humidity (%RH):\", (humidity/1024)))  Sys.sleep(1) }"},{"path":"https://mnr.github.io/rpigpior/articles/rpi_i2c.html","id":"about-i2c-on-raspberry-pi","dir":"Articles","previous_headings":"","what":"About I2C on Raspberry Pi","title":"rpi_i2c","text":"Inter-Integrated Circuit Communication Uses Serial Data Line (SDA, board pin 3) Serial Clock Line (SCL, board pin 5) RPI two hardware i2c buses. Software buses can also created","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_i2c.html","id":"installing-i2c","dir":"Articles","previous_headings":"","what":"Installing I2C","title":"rpi_i2c","text":"Requires turning i2c Raspi-config use i2cdetect -y 1 show devices connected i2c bus","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_i2c.html","id":"i2c-tools","dir":"Articles","previous_headings":"","what":"i2c-tools","title":"rpi_i2c","text":"i2c-tools already installed Raspberry Pi Operating System i2cset set one byte i2cget get one byte i2cdump i2cdetect -y 1 i2ctransfer send/receive multiple bytes https://github.com/epsylon3/android_external_i2c-tools/tree/gingerbread/tools","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_i2c.html","id":"handling-errors","dir":"Articles","previous_headings":"i2c-tools","what":"Handling Errors:","title":"rpi_i2c","text":"stop(“must specify chip_address integer 0x08 0x77”) stop(“must specify data_address integer 0x00 0xFF”) i2cdetect command results error either installed i2c-tools need use 0 rather 1 device detected don’t see address either connected device properly correctly enabled i2c interface","code":""},{"path":[]},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"hardware-pwm-vs-software-pwm","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi","what":"Hardware PWM vs Software PWM","title":"Raspberry Pi and PWM","text":"Raspberry Pi exposes two PWM channels Broadcom chip. appear lines also supply GPIO connections Broadcom ALT functions need called. PWM0 appears board pins 12 (GPIO18) 32 (GPIO12). PWM1 appears board pins 33 (GPIO13) 35 (GPIO19). causes confusing situation two ways: Don’t confuse board pin 12 GPIO12 (board pin 32). connected BCM PWM0 want use two PWM channels, certain combinations pins provide two channels. combinations board pins (12,33), (32,33), (12,35), (32,35) rpi_pwm() handles issues. stick board pin numbers, work . go astray, rpi_pwm() stop warn . Raspberry Pi analog audio output uses PWM channels. can’t use hardware PWM audio output time. Although possible create software PWM, isn’t advised due latency linux R. rpigpior supply software PWM channels.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"enabling-hardware-pwm-on-the-raspberry-pi","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi","what":"Enabling hardware PWM on the Raspberry Pi","title":"Raspberry Pi and PWM","text":"Raspberry Pi OS uses device tree enable hardware PWM. ’ll need bit behind--scenes editing set . , edit /boot/config.txt root. Raspberry Pi, open terminal window Use command sudo nano /boot/config.txt. open nano text editor display contents /boot/config.txt. Add dtoverlay command end file. easiest way determine command add /boot/config.txt ask rpi_pwm() help. Set pwm_debug=TRUE select pins want use. aren’t enabled, rpi_pwm() stop provide correct dtoverlay string. looks something like dtoverlay=pwm,pin18,func-2 change depending pins chosen. want math , excellent guide available github.com/dotnet. also linux documentation discusses Enabling one PWM channel Enabling dual pwm channel Use control-o write file, control-x exit nano Reboot Raspberry Pi enact change. Note rebuild SD card reinstall Raspberry Pi OS OS card, ’ll need repeat step.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"how-to-use-rpi_pwm","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi","what":"How to use rpi_pwm()","title":"Raspberry Pi and PWM","text":"’s example: …","code":"rpi_pwm(c(12,33), pwm_period = 50000, pwm_dutycycle = 25000)  # This will enable PWM0 and PWM1 with a period (frequency) of 50000 and a duty cycle of 25000. That is to say, 50% power. rpi_pwm(12, pwm_period = 50000, pwm_dutycycle = 10000)  # This will turn PWM0 down to 20%"},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"handling-errors","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi","what":"Handling Errors:","title":"Raspberry Pi and PWM","text":"set pwm_debug = TRUE rpi_pwm() run diagnostics goes.","code":"rpi_pwm(12, pwm_period = 50000, pwm_dutycycle = 10000, pwm_debug = TRUE)"},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"invalid-pwm-pin","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi > Handling Errors:","what":"Invalid PWM pin:","title":"Raspberry Pi and PWM","text":"’ve called rpi_pwm(pin_number) pin (pins) specified don’t supply hardware Pulse Width Modulation. Raspberry Pi, board pins 12, 32, 33, 35. Keep mind rpi_pwm() specifies pins board pins - GPIO BCM pins. Lots documentation refer pin numbering schemes.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"invalid-pwm-pin-combination","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi > Handling Errors:","what":"Invalid PWM pin combination:","title":"Raspberry Pi and PWM","text":"know now, Raspberry Pi two hardware PWM channels, channel connected two pins: PWM0 appears board pins 12 (GPIO18) 32 (GPIO12). PWM1 appears board pins 33 (GPIO13) 35 (GPIO19). …going use two PWM channels, need use pins connected different channels. Since board pin 12 32 connected PWM0, nonsense use rpi_pwm(pin_number = c(12,32). Instead, valid combinations: rpi_pwm(pin_number = c(12,33) rpi_pwm(pin_number = c(12,35) rpi_pwm(pin_number = c(32,33) rpi_pwm(pin_number = c(32,35) try select invalid combination pwm_debut = TRUE receive error.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"pwm-not-enabled","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi > Handling Errors:","what":"PWM not enabled:","title":"Raspberry Pi and PWM","text":"PWM channel (channels) selected yet enabled. Enabling PWM described section titled Enabling hardware PWM Raspberry Pi . error message rpi_pwm supplies string ’ll need paste /boot/config.txt.","code":""},{"path":"https://mnr.github.io/rpigpior/articles/rpi_pwm.html","id":"notes","dir":"Articles","previous_headings":"Pulse Width Modulation on the Raspberry Pi","what":"Notes:","title":"Raspberry Pi and PWM","text":"Linux driver implementer’s API guide chapter PWM : https://www.kernel.org/doc/html/v5.10/driver-api/pwm.html","code":""},{"path":"https://mnr.github.io/rpigpior/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mark Niemann-Ross. Author, maintainer, copyright holder.","code":""},{"path":"https://mnr.github.io/rpigpior/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Niemann-Ross M (2023). rpigpior: Provides R Access Raspberry Pi. R package version 0.1.0,  https://mnr.github.io/rpigpior/, https://github.com/mnr/rpigpior.","code":"@Manual{,   title = {rpigpior: Provides R with Access to the Raspberry Pi},   author = {Mark Niemann-Ross},   year = {2023},   note = {R package version 0.1.0,  https://mnr.github.io/rpigpior/},   url = {https://github.com/mnr/rpigpior}, }"},{"path":"https://mnr.github.io/rpigpior/index.html","id":"rpigpior","dir":"","previous_headings":"","what":"Provides R with Access to the Raspberry Pi","title":"Provides R with Access to the Raspberry Pi","text":"rpigpior allows R programming language access Raspberry Pi GPIO using libgpiod. libgpiod already included Raspbian, nothing else install. rpigpior provides tools: .rpi - Returns TRUE code running Raspbian rpi_get - Returns value board level pin (1-40) error pin isn’t data line (3.3v, 5v, GROUND) rpi_set - Sets pin rpi_monitor - watches pin number rising falling events rpi_pwm - provides diagnostics support hardware pulse width modulation rpi_i2c_get - retrieve value i2c connection rpi_i2c_set - set i2c register value","code":""},{"path":"https://mnr.github.io/rpigpior/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Provides R with Access to the Raspberry Pi","text":"rpigpior hosted github. arrives cran, can install development version rpigpior GitHub : documentation tell use devtools, install.packages(\"devtools\") Raspberry Pi onerous task. ’ve installed, use library just like R package:","code":"library(remotes) remotes::install_github(\"mnr/rpigpior\") library(rpigpior)"},{"path":"https://mnr.github.io/rpigpior/index.html","id":"is-this-a-raspberry-pi","dir":"","previous_headings":"","what":"Is this a Raspberry Pi?","title":"Provides R with Access to the Raspberry Pi","text":"’s helpful check code running Raspberry Pi.","code":"if ( is.rpi() ) {    print(\"Yes, this is a RPi\") } else {    print (\"No, this is not a RPi\") }"},{"path":"https://mnr.github.io/rpigpior/index.html","id":"reading-a-pin","dir":"","previous_headings":"","what":"Reading a pin","title":"Provides R with Access to the Raspberry Pi","text":"connect switch board pin 40, code read : assumes switch board pin 40 “pushed” closed. way, diagram located articles section website (identified package description)","code":"library(rpigpior)  rpi_get(40) # reads board pin 40 rpi_get(c(7,40)) # reads board pins 7 and 40  > GPIO004  GPIO21         0       1"},{"path":"https://mnr.github.io/rpigpior/index.html","id":"turning-pins-on-and-off","dir":"","previous_headings":"","what":"Turning pins on and off","title":"Provides R with Access to the Raspberry Pi","text":"LEDs connected board pin 19, 21, 23, code turn , one , ","code":"library(rpigpior)  toggleThese <- c(19,21,23) rpi_set(toggleThese,1) Sys.sleep(1) rpi_set(toggleThese, c(1,0,1)) Sys.sleep(1) rpi_set(toggleThese, 0)"},{"path":"https://mnr.github.io/rpigpior/index.html","id":"related-notes","dir":"","previous_headings":"","what":"Related notes:","title":"Provides R with Access to the Raspberry Pi","text":"Related mailing list: linux-gpio@vger.kernal.org","code":""},{"path":"https://mnr.github.io/rpigpior/reference/is.rpi.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide information about the Operating System — is.rpi","title":"Provide information about the Operating System — is.rpi","text":"Returns TRUE code running Raspbian return information operating system.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/is.rpi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide information about the Operating System — is.rpi","text":"","code":"is.rpi(onlyThis = \"IsThisRPI\")"},{"path":"https://mnr.github.io/rpigpior/reference/is.rpi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Provide information about the Operating System — is.rpi","text":"onlyThis value passed onlyThis, .rpi() return logical 'onlyThis' specified, '.rpi()' return value field /etc/os-release. typical values found os-release PRETTY_NAME concatenation NAME, VERSION_ID, VERSION NAME name OS, typically \"Raspbian GNU/LINUX\" VERSION_ID version. Currently = 11 VERSION concatenation VERSION_ID (VERSION_CODENAME) VERSION_CODENAME OS Name. Currently = \"bullseye\" ID OS. Currently = \"raspbian\" ID_LIKE OS base. Currently = \"debian\" HOME_URL Currently = \"http://www.raspbian.org\" SUPPORT_URL Currently = \"http://www.raspbian.org/RaspbianForums\" BUG_REPORT Currently = \"http://www.raspbian.org/RaspbianBugs\"","code":""},{"path":"https://mnr.github.io/rpigpior/reference/is.rpi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide information about the Operating System — is.rpi","text":"`onlyThis` specified, returns value. Otherwise returns TRUE running Raspbian","code":""},{"path":"https://mnr.github.io/rpigpior/reference/is.rpi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Provide information about the Operating System — is.rpi","text":"","code":"if (FALSE) { # is.rpi() is.rpi() is.rpi(\"NAME\") }"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the value of a RPi Pin — rpi_get","title":"Retrieve the value of a RPi Pin — rpi_get","text":"Returns value one specified board-level pin number (0-40). Stops pin valid data line.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the value of a RPi Pin — rpi_get","text":"","code":"rpi_get(pin_number)"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the value of a RPi Pin — rpi_get","text":"pin_number Raspberry Pi GPIO board level pin number 1 40. example, Pin #1 located upper left provides 3.3 volts. Pin #40 located lower right location GPIO21.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the value of a RPi Pin — rpi_get","text":"named vector value pin number.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the value of a RPi Pin — rpi_get","text":"","code":"if (FALSE) { # is.rpi() if (FALSE)  rpi_get(1) # produces error since pin #1 is not data  rpi_get(40) # returns a named vector of the state of GPIO21. i.e. return[\"GPIO21\"] = 1 rpi_get(c(7, 40)) # returns a named vector of values from pins 7 and 40 }"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a byte from an i2c device — rpi_i2c_get","title":"Return a byte from an i2c device — rpi_i2c_get","text":"Return byte i2c device","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a byte from an i2c device — rpi_i2c_get","text":"","code":"rpi_i2c_get(chip_address, data_address, data_size = \"b\")"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return a byte from an i2c device — rpi_i2c_get","text":"chip_address integer 0x03 0x77. Use i2cdetect -y 1 identify address data_address integer 0x00 0xFF. come chip documentation data_size read byte (b) word (w) data_address","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return a byte from an i2c device — rpi_i2c_get","text":"data i2c device located chip_address data_address","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return a byte from an i2c device — rpi_i2c_get","text":"","code":"if (FALSE) { # is.rpi() #' # get a byte from an i2c device located at 0x77 rpi_i2c_get(chip_address = 0x77, data_address = 0xfa, data_size = 'b') }"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Write data to an i2c device — rpi_i2c_set","title":"Write data to an i2c device — rpi_i2c_set","text":"Writes byte, word, data block i2c device.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write data to an i2c device — rpi_i2c_set","text":"","code":"rpi_i2c_set(chip_address, data_address, value, data_size = \"b\")"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write data to an i2c device — rpi_i2c_set","text":"chip_address integer 0x03 0x77. Use i2cdetect -y 1 identify address data_address integer 0x00 0xFF. come chip documentation value byte (0xff), word (0xffff), SMBus (32 bytes) I2C Block data_size data_size must one \"b\", \"w\", \"s\", \"\"","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write data to an i2c device — rpi_i2c_set","text":"void","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_i2c_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write data to an i2c device — rpi_i2c_set","text":"","code":"if (FALSE) { # is.rpi() }"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_monitor.html","id":null,"dir":"Reference","previous_headings":"","what":"Monitor an RPi pin — rpi_monitor","title":"Monitor an RPi pin — rpi_monitor","text":"Watch Raspberry pi GPIO pin (pins) changes.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_monitor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Monitor an RPi pin — rpi_monitor","text":"","code":"rpi_monitor(pin_number, numEvents = 0, edge = \"both\")"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_monitor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Monitor an RPi pin — rpi_monitor","text":"pin_number one pin numbers found Raspberry pi GPIO. Use actual pin numbers (.e. 1:40) numEvents number events collect. Defaults 10 edge rising|falling|","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_monitor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Monitor an RPi pin — rpi_monitor","text":"list events  raw text event event: RISING EDGE|FALLING EDGE line: bcm line (board pin) exhibiting change timestamp: seconds component timestamp: nanoseconds component","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_monitor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Monitor an RPi pin — rpi_monitor","text":"","code":"if (FALSE) { # is.rpi() # \\donttest{ rpi_monitor(21) rpi_monitor(21, numEvents=20) # } }"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pinToBCM.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts a RPi pin number to BCM line — rpi_pinToBCM","title":"Converts a RPi pin number to BCM line — rpi_pinToBCM","text":"Look board pin number return BCM_line line_name     Pin number physical board Raspberry pi.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pinToBCM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts a RPi pin number to BCM line — rpi_pinToBCM","text":"","code":"rpi_pinToBCM(pin_number)"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pinToBCM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts a RPi pin number to BCM line — rpi_pinToBCM","text":"pin_number pin found Raspberry Pi board. Numbered 1 40.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pinToBCM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts a RPi pin number to BCM line — rpi_pinToBCM","text":"named vector.      bcm_line = broadcom line connected pin      pin_name = broadcom name RXD1 GPIO21","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pinToBCM.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converts a RPi pin number to BCM line — rpi_pinToBCM","text":"checks valid range pins (1:40) valid input/output lines. prevents trying read 3.3v ground line.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pinToBCM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts a RPi pin number to BCM line — rpi_pinToBCM","text":"","code":"if (FALSE) { # is.rpi() rpi_pinToBCM(1) # produces error since pin #1 is not data rpi_pinToBCM(40) # returns a named vector where bcm_line = 21 and pin_name = GPIO21 }"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pin_desc.html","id":null,"dir":"Reference","previous_headings":"","what":"Raspberry Pi Pins — rpi_pin_desc","title":"Raspberry Pi Pins — rpi_pin_desc","text":"board-level description 40 GPIO pins found Raspberry Pi.     different wiring pi BCM numbering schemes. Instead, reflects function pins physical location board.","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pin_desc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Raspberry Pi Pins — rpi_pin_desc","text":"","code":"rpi_pin_desc"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pin_desc.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Raspberry Pi Pins — rpi_pin_desc","text":"## `rpi_pin_desc` data frame 40 rows two columns: description. Primary function pin secondary. Secondary function pin valid_PWM_pair_1, valid_PWM_pair_2. Used rpi_pwm() determine valid PWM pins channel combinations. PWM_channel. Unambiguously relates PWM channel board pin","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pin_desc.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Raspberry Pi Pins — rpi_pin_desc","text":"https://www.raspberrypi.com/documentation/computers/os.html#gpio---40-pin-header","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pwm.html","id":null,"dir":"Reference","previous_headings":"","what":"Provide R with access to PWM — rpi_pwm","title":"Provide R with access to PWM — rpi_pwm","text":"Provides R programming language access Raspberry Pi hardware Pulse Width Modulation (PWM)","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pwm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provide R with access to PWM — rpi_pwm","text":"","code":"rpi_pwm(   pin_number = 12,   pwm_period = 50000,   pwm_dutycycle = 25000,   pwm_debug = FALSE )"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pwm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Provide R with access to PWM — rpi_pwm","text":"pin_number One two pins hardware PWM. Must 12, 32, 33, 35. two pins selected, must one combinations: (12,33), (32,33), (12,35), (32,35) pwm_period length cycle. aka Frequency. 15 greater, less 1000000 pwm_dutycycle amount time cycle . pwm_debug TRUE, checks Raspberry Pi OS settings PWM provides diagnostics","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pwm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provide R with access to PWM — rpi_pwm","text":"void     `rpi_pwm()` provides extensive error checking. Possible errors include:  Invalid PWM pin: Hardware PWM supplied pins 12, 32, 33, 35. Invalid PWM pin combination: combination pins select PWM0 PWM1 PWM enabled: PWM channel enabled (see https://mnr.github.io/rpigpior/articles/rpi_pwm.html fixing errors)","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pwm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Provide R with access to PWM — rpi_pwm","text":"two PWM lines available Raspberry Pi - pwm0 pwm1. Although possible create software PWM, advised due latency linux R.     might helpful read article `rpi_pwm()` located [rpigpior website](https://mnr.github.io/rpigpior/articles/rpi_pwm.html).","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_pwm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Provide R with access to PWM — rpi_pwm","text":"","code":"if (FALSE) { # is.rpi() rpi_pwm(12) # provides 50% PWM to pin 12 (PWM0)  #' # provides 20% PWM to pin 12 (PWM0) and pin 33 (PWM1) rpi_pwm(c(12,33), pwm_period = 50000, pwm_dutycycle = 10000) }"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn lines on or off — rpi_set","title":"Turn lines on or off — rpi_set","text":"Turn lines ","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn lines on or off — rpi_set","text":"","code":"rpi_set(pin_number, onOff)"},{"path":"https://mnr.github.io/rpigpior/reference/rpi_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn lines on or off — rpi_set","text":"pin_number one pin numbers found Raspberry pi GPIO. Use actual pin numbers (.e. 1:40) onOff vector length pin_number values 0 1 turn line ","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn lines on or off — rpi_set","text":"value returned","code":""},{"path":"https://mnr.github.io/rpigpior/reference/rpi_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn lines on or off — rpi_set","text":"","code":"if (FALSE) { # is.rpi() # turns pin 19 on, 21 off, and 23 on. # This corresponds to gpio09, gpio10, and gpio11 rpi_set(pin_number = c(19, 21, 23), onOff = c(1,0,1))  toggleThesePins <- c(19,21,23) rpi_set(toggleThesePins, 1) # turns all three pins on. onOff is recycled Sys.sleep(1) rpi_set(toggleThesePins, c(0,1,0)) # turns off pins 19 and 23 Sys.sleep(1) rpi_set(toggleThesePins, 0) # turns off all pins }"},{"path":"https://mnr.github.io/rpigpior/reference/rpigpior-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rpigpior: Provides R with Access to the Raspberry Pi — rpigpior-package","title":"rpigpior: Provides R with Access to the Raspberry Pi — rpigpior-package","text":"provides R access Raspberry Pi General Purpose Input Output (GPIO) via 'libgpiod'. includes detecting gpio chip well turning pins via [gpioset()] reading state pins via [gpioget()]. additional libraries need installed; Raspbian includes 'libgpiod' part standard installation.","code":""},{"path":[]},{"path":"https://mnr.github.io/rpigpior/reference/rpigpior-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rpigpior: Provides R with Access to the Raspberry Pi — rpigpior-package","text":"Maintainer: Mark Niemann-Ross mark@niemannross.com (ORCID) [copyright holder]","code":""},{"path":"https://mnr.github.io/rpigpior/news/index.html","id":"rpigpior-010","dir":"Changelog","previous_headings":"","what":"rpigpior 0.1.0","title":"rpigpior 0.1.0","text":"rpi_i2c_get() rpi_i2c_set() rpi_pwm() rpi_monitor() rpi_set() rpi_get() rpi_pinToBCM() is_rpi() Added NEWS.md file track changes package.","code":""}]
